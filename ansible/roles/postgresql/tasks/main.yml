---
# PostgreSQL role - PostGIS container and migrations
# Preserves existing database data when preserve_existing_database is true

- name: Check if PostgreSQL container exists
  community.docker.docker_container_info:
    name: "{{ postgres_container }}"
  register: postgres_container_info

- name: Display existing container status
  ansible.builtin.debug:
    msg: "PostgreSQL container exists: {{ postgres_container_info.exists }}, running: {{ postgres_container_info.container.State.Running | default(false) }}"
  when: postgres_container_info.exists

- name: Create PostgreSQL data volume
  community.docker.docker_volume:
    name: "{{ postgres_volume }}"
    state: present

# If container exists and preserve_existing_database is true, just ensure it's running and in network
- name: Ensure existing PostgreSQL container is running
  community.docker.docker_container:
    name: "{{ postgres_container }}"
    state: started
  when:
    - postgres_container_info.exists
    - preserve_existing_database | default(true)

- name: Add existing container to Docker network
  ansible.builtin.shell: |
    docker network connect {{ docker_network }} {{ postgres_container }} 2>/dev/null || true
  when:
    - postgres_container_info.exists
    - preserve_existing_database | default(true)
  changed_when: false

# If container doesn't exist, create it
- name: Create new PostgreSQL container
  community.docker.docker_container:
    name: "{{ postgres_container }}"
    image: "{{ postgres_image }}"
    state: started
    restart_policy: unless-stopped
    networks:
      - name: "{{ docker_network }}"
    ports:
      - "5432:5432"
    env:
      POSTGRES_USER: "{{ db_user }}"
      POSTGRES_PASSWORD: "{{ db_password }}"
      POSTGRES_DB: "{{ db_name }}"
    volumes:
      - "{{ postgres_volume }}:/var/lib/postgresql"
  when: not postgres_container_info.exists
  register: postgres_container_result

- name: Wait for PostgreSQL to be ready
  ansible.builtin.shell: |
    for i in $(seq 1 30); do
      docker exec {{ postgres_container }} pg_isready -U {{ db_user }} -d {{ db_name }} && exit 0
      sleep 2
    done
    exit 1
  args:
    executable: /bin/bash
  changed_when: false
  retries: 3
  delay: 5

- name: Create migrations tracking directory
  ansible.builtin.file:
    path: "{{ app_home }}/.migrations"
    state: directory
    owner: "{{ app_user }}"
    group: "{{ app_user }}"
    mode: "0755"

# Dynamic migration discovery - uses scripts/ from cloned repo
# Order: setup_notice_boards_db.sql first, then migrate_*.sql sorted, then setup_indexes.sql last
- name: Find all migration files
  ansible.builtin.find:
    paths: "{{ app_dir }}/scripts"
    patterns:
      - "setup_notice_boards_db.sql"
      - "migrate_notice_boards_*.sql"
      - "setup_indexes.sql"
  register: migration_files
  tags: [migrations]

- name: Build ordered migration list
  ansible.builtin.set_fact:
    ordered_migrations: >-
      {{
        (migration_files.files | selectattr('path', 'search', 'setup_notice_boards_db.sql') | list) +
        (migration_files.files | selectattr('path', 'search', 'migrate_notice_boards_') | sort(attribute='path') | list) +
        (migration_files.files | selectattr('path', 'search', 'setup_indexes.sql') | list)
      }}
  tags: [migrations]

- name: Display migrations to apply
  ansible.builtin.debug:
    msg: "Found {{ ordered_migrations | length }} migration files: {{ ordered_migrations | map(attribute='path') | map('basename') | list }}"
  tags: [migrations]

- name: Apply migrations
  ansible.builtin.shell: |
    docker exec -i {{ postgres_container }} psql -U {{ db_user }} -d {{ db_name }} < {{ item.path }}
  args:
    creates: "{{ app_home }}/.migrations/{{ item.path | basename }}.done"
  loop: "{{ ordered_migrations }}"
  loop_control:
    label: "{{ item.path | basename }}"
  register: migration_results
  tags: [migrations]

- name: Mark migrations as done
  ansible.builtin.file:
    path: "{{ app_home }}/.migrations/{{ item.item.path | basename }}.done"
    state: touch
    owner: "{{ app_user }}"
    mode: "0644"
  loop: "{{ migration_results.results }}"
  loop_control:
    label: "{{ item.item.path | basename }}"
  when: item.changed
  tags: [migrations]
